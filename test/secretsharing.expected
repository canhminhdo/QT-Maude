==========================================
reduce in SECRETE-SHARING-CHECK : modelCheck(init, ssProp) .
result Bool: true
==========================================
search in SECRETE-SHARING : init =>* {OCs:Soup{OComp} qstate: Q:Qubit prob:
    P:Scalar isEnd: true} such that (-1 . qubitAt(Q:Qubit, 3) == qubitAt(
    initState, 0) or qubitAt(Q:Qubit, 3) == qubitAt(initState, 0)) and P:Scalar
    > 0 = true .

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 0, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |0>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 0, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |0>) (q[2]: |1>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 1, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |1>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 0, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |0>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 1, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |1>) (q[2]: |1>) q[3]: (a .* -1) . |0> + (b .*
    -1) . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 0, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |0>) (q[2]: |1>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 1, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |1>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Scalar --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 1, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |1>) (q[2]: |1>) q[3]: (a .* -1) . |0> + (b .*
    -1) . |1>
P:Scalar --> 1/8

No more solutions.
Bye.
