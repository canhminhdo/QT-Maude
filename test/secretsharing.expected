==========================================
reduce in SECRETE-SHARING-CHECK : modelCheck(init, ssProp) .
result Bool: true
==========================================
search in SECRETE-SHARING : init =>* {OCs:Soup{OComp} qstate: Q:Qubit prob:
    P:Complex isEnd: true} such that P:Complex > 0 implies -1 . qubitAt(
    Q:Qubit, 3) == qubitAt(qstate(init), 0) or qubitAt(Q:Qubit, 3) == qubitAt(
    qstate(init), 0) = true .

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 0, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |0>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 0, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |0>) (q[2]: |1>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 1, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |1>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 0, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |0>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 0, 1 |-> 1, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |0>) (q[1]: |1>) (q[2]: |1>) q[3]: (a .* -1) . |0> + (b .*
    -1) . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 0, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |0>) (q[2]: |1>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 1, 2 |-> 0) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |1>) (q[2]: |0>) q[3]: a . |0> + b . |1>
P:Complex --> 1/8

OCs:Soup{OComp} --> bits: (0 |-> 1, 1 |-> 1, 2 |-> 1) actions: nil
Q:Qubit --> (q[0]: |1>) (q[1]: |1>) (q[2]: |1>) q[3]: (a .* -1) . |0> + (b .*
    -1) . |1>
P:Complex --> 1/8

No more solutions.
Bye.
